# ボクセル地形の改善

## 使用シェーダー
- `Transvoxel.hlsli`
- `Transvoxel.as.hlsl`
- `Transvoxel.ms.hlsl`
- `Transvoxel.ps.hlsl`
- `TransvoxelTables.hlsli`
- `LODInfo.hlsli`

## 項目1: Transvoxelアルゴリズムの実装
1. チャンクの境界判定
2. 13個のサンプリング点のサンプリング
3. サンプリング結果からメッシュを計算

## 現状
- basePosの位置にメッシュを生成出来ている
- 出力されたメッシュの形状がおかしい

---

## 問題分析と修正ポイント

### ❌ 問題1: インデックス生成時のオフセット未適用（重大）

**場所**: `Transvoxel.ms.hlsl` (325-331行目)

**問題**: 
```hlsl
// 現在のコード
tris[triOffset + t] = uint3(i0, i1, i2);
```
`i0, i1, i2`は`transitionCellData`から取得したローカルインデックス（0-11程度）ですが、
実際の頂点は`vertOffset`から始まる位置に書き込まれています。

**修正**:
```hlsl
tris[triOffset + t] = uint3(vertOffset + i0, vertOffset + i1, vertOffset + i2);
```

---

### ⚠️ 問題2: 頂点データテーブルの参照方法

**場所**: `Transvoxel.ms.hlsl` (278行目)

**現在**:
```hlsl
uint vData = tTransitionVertexData[caseCode * kTransitionVertexDataStride + v];
```

**確認が必要**:
- `tTransitionVertexData`は512ケース全て分のデータを持っているか？
- それとも`cellClass`(56クラス)でインデックスするべきか？

`TransvoxelTables.hlsli`を見ると、`tTransitionVertexData`は512ケース×12頂点=6144エントリがあるので、
`caseCode * kTransitionVertexDataStride`は正しい可能性が高い。

---

### ⚠️ 問題3: 頂点位置の変換処理（潜在的問題）

**場所**: `Transvoxel.ms.hlsl` (295-313行目)

回転・反転処理の順序:
1. `kTransitionCornerOffsets`から標準空間のオフセットを取得
2. 等値面補間で`virtualPos`を計算
3. 反転を戻す（Un-Invert）
4. 回転を戻す（Un-Permute）
5. ワールド座標に変換

**確認事項**:
- サンプリング時（`GetMappedDensity`）と頂点生成時で、変換の順序が逆になっているか？
  - サンプリング: 回転 → 反転
  - 頂点生成: 反転を戻す → 回転を戻す（✓正しい）

---

### ⚠️ 問題4: 三角形のワインディングオーダー

**確認事項**:
- 面が反転している場合、三角形の頂点順序を逆にする必要があるかもしれない
- `kInvert`で反転処理を行った方向に応じて、`(i0, i1, i2)`を`(i0, i2, i1)`に変更する

```hlsl
// 例: ワインディング修正
bool needsInvert = (classData & 0x80) != 0; // Transvoxelの反転フラグ
if (needsInvert) {
    tris[triOffset + t] = uint3(vertOffset + i0, vertOffset + i2, vertOffset + i1);
} else {
    tris[triOffset + t] = uint3(vertOffset + i0, vertOffset + i1, vertOffset + i2);
}
```

---

## 修正手順

### Step 1: インデックスオフセットの修正
```hlsl
// Transvoxel.ms.hlsl 325-331行目を修正
for (uint t = 0; t < triangleCount; ++t) {
    uint i0 = transitionCellData[cellClass].vertexIndex[t * 3 + 0];
    uint i1 = transitionCellData[cellClass].vertexIndex[t * 3 + 1];
    uint i2 = transitionCellData[cellClass].vertexIndex[t * 3 + 2];
    
    tris[triOffset + t] = uint3(vertOffset + i0, vertOffset + i1, vertOffset + i2);
}
```

### Step 2: 結果を確認
- 修正後、メッシュの形状が改善されるか確認
- 面が裏返っていないか確認

### Step 3: ワインディングオーダーの調整（必要に応じて）
- 面が裏返っている場合、`classData & 0x80`をチェックして頂点順序を反転

---

## デバッグ用チェックリスト

- [ ] `caseCode`が0と511以外で正しく計算されているか
- [ ] `cellClass`が正しくルックアップされているか（0-55の範囲）
- [ ] `vertexCount`と`triangleCount`が期待値と一致しているか
- [ ] 頂点位置が正しいワールド座標に変換されているか
- [ ] 法線が正しく計算されているか

---

## PIXを使わないビジュアルデバッグ方法

PIXでメモリ不足になる場合、以下の方法で頂点カラーを使ってデバッグできます。

### 方法1: caseCodeを色で可視化

`Transvoxel.ms.hlsl` の `ProcessTransvoxelVertex` を修正して、
デバッグ情報を頂点カラーとして出力します。

```hlsl
// caseCodeを色として可視化（0-511 → RGB）
float3 debugColor = float3(
    float((caseCode >> 0) & 0x07) / 7.0,  // R: bits 0-2
    float((caseCode >> 3) & 0x07) / 7.0,  // G: bits 3-5
    float((caseCode >> 6) & 0x07) / 7.0   // B: bits 6-8
);
vOut.color = float4(debugColor, 1.0);
```

### 方法2: cellClassを色で可視化

```hlsl
// cellClass (0-55) を色として可視化
float hue = float(cellClass) / 55.0;
float3 debugColor = float3(hue, 1.0 - hue, 0.5);
vOut.color = float4(debugColor, 1.0);
```

### 方法3: 方向（dirIndex）を色で可視化

```hlsl
// 6方向を異なる色で表示
static const float3 kDirColors[6] = {
    float3(1, 0, 0),    // 0: -X 赤
    float3(0.5, 0, 0),  // 1: +X 暗い赤
    float3(0, 1, 0),    // 2: -Y 緑
    float3(0, 0.5, 0),  // 3: +Y 暗い緑
    float3(0, 0, 1),    // 4: -Z 青
    float3(0, 0, 0.5)   // 5: +Z 暗い青
};
vOut.color = float4(kDirColors[dirIndex], 1.0);
```

### 方法4: 頂点位置の正規化値を可視化

```hlsl
// ローカル座標を色として表示（位置が正しいか確認）
float3 normalizedPos = saturate(worldPos / float(voxelTerrainInfo.chunkSize));
vOut.color = float4(normalizedPos, 1.0);
```

### 方法5: 特定のcaseCodeのみ表示

問題のあるケースを特定するため、特定のcaseCodeのみ描画：

```hlsl
// 特定のcaseCode以外は描画しない
if (caseCode != 特定の値) {
    // 頂点を画面外に配置
    vOut.position = float4(0, 0, -1, 1);
}
```

### 実装例: デバッグモード付きProcessTransvoxelVertex

```hlsl
// デバッグモード定義（0: 通常, 1: caseCode, 2: cellClass, 3: direction, 4: position）
#define DEBUG_MODE 0

VertexOut ProcessTransvoxelVertex(float3 worldPos, float3 chunkOrigin, uint chunkID, 
                                   uint caseCode, uint cellClass, uint dirIndex) {
    VertexOut vOut;
    
    vOut.worldPosition = float4(worldPos + chunkOrigin, 1.0);
    vOut.position = mul(vOut.worldPosition, viewProjection.matVP);
    vOut.normal = CalculateNormal(worldPos, chunkID);
    
#if DEBUG_MODE == 1
    // caseCode可視化
    vOut.color = float4(
        float((caseCode >> 0) & 0x07) / 7.0,
        float((caseCode >> 3) & 0x07) / 7.0,
        float((caseCode >> 6) & 0x07) / 7.0, 1.0);
#elif DEBUG_MODE == 2
    // cellClass可視化
    float h = float(cellClass) / 55.0;
    vOut.color = float4(h, 1.0 - h, 0.5, 1.0);
#elif DEBUG_MODE == 3
    // direction可視化
    static const float3 kDirColors[6] = {
        float3(1,0,0), float3(0.5,0,0), float3(0,1,0),
        float3(0,0.5,0), float3(0,0,1), float3(0,0,0.5)
    };
    vOut.color = float4(kDirColors[dirIndex], 1.0);
#elif DEBUG_MODE == 4
    // position可視化
    vOut.color = float4(saturate(worldPos / 32.0), 1.0);
#else
    vOut.color = float4(1.0, 1.0, 1.0, 1.0);
#endif
    
    return vOut;
}
```

### ピクセルシェーダー側の対応

`Transvoxel.ps.hlsl` で頂点カラーを出力：

```hlsl
// デバッグモード時は頂点カラーをそのまま出力
output.color = input.color;
```